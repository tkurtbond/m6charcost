;;; sm6rst.scm - Convert Mini-Six Characters in JSON to ReStructuredText.
;;;
;;; Remember: ~/current/RPG/the-kids/Mini-Six/Star-Wars/kids-pcs/kids-pcs-3.json
(module sm6rst ()
  (import args)
  (import format)
  (import loop)
  (import scheme)
  (import matchable)
  (import medea)
  (import simple-loops)
  (import srfi-13)
  (import srfi-19)
  (import srfi-69)
  (import (chicken base))
  (import (chicken irregex))
  (import (chicken port))
  (import (chicken process-context))

  (define (die status . args)
    (format (current-error-port) "~A: fatal error: " (program-name))
    (apply format (cons (current-error-port) args))
    (format (current-error-port) "\n")
    (exit status))

  ;; (put 'when-in-hash 'scheme-indent-function 1)
  (define-syntax when-in-hash
    (syntax-rules ()
      ((_ (var key hash-table) b1 ...)
       (when (hash-table-exists? hash-table key)
	 (let ((var (hash-table-ref hash-table key)))
	   b1 ...)))))

  (define (output-character character)
    (format #t "Character:~%")
    (hash-table-walk character (lambda (k v) (format #t "~S: ~S~%" k v))))

  (define (output-notes-line line)
    (if (and substitute-from (irregex-match substitute-from line))
        (format #t "~A~%" (make-string (string-length line) substitute-to))
        (format #t "~A~%" line)))

  (define (print-character character)
    (when debug
      (output-character character))
    (let ((statistics '("Might" "Agility" "Wit" "Charm"))
          (header "") (outer-name #f))
      (when-in-hash (name "Name" character)
	(set! header (format #f "~A" name))
        (set! outer-name name))
      ;; Using an Unicode EM DASH makes the underline longer.  utf8 egg???
      ;; No, use a hypen-minus, because it appears in the PDF outline, and
      ;; groff doesn't get non-ascii characters right in that.
      (when-in-hash (archetype "Archetype" character)
	(set! header (format #f "~A - ~A" header archetype)))
      (when-in-hash (number "Number" character)
	(set! header (format #f "~A ×~A" header number)))
      (when output-player
        (when-in-hash (player "Player" character)
          (set! header (format #f "~A (~A)" header player))))
      (format #t "~A~%" header)
      (format #t "~A~%~%" (make-string (string-length header) underline))
      (when-in-hash (quote "Quote" character)
        (format #t "*“~A”*~%~%" quote))
      (when-in-hash (description "Description" character)
        (format #t "~A~%~%" description))
      (when-in-hash (scale "Scale" character)
        (format #t "| **Scale:** ~A~%" scale))
      (when-in-hash (stats "Statistics" character)
	(set! statistics (vector->list stats)))
      ;; This works for absolute skills listed with stats.
      (do-list stat-name statistics
	(unless (hash-table-exists? character stat-name)
	  (die 1 "Missing stat name: ~A" stat-name))
	(let ((stat-value (hash-table-ref character stat-name)))
	  (match-let ((#(stat-dice skills ...) stat-value))
            (format #t "| **~a ~a**" stat-name stat-dice)
            (loop for skill in skills
                  for i from 1
                  when (= i 1) do (format #t " — ")
                  when (> i 1) do (format #t ", ")
		  do (begin
		       (match-let ((#(skill-name skill-dice) skill))
                         (format #t "~A ~A" skill-name skill-dice))))))
        (format #t "~%"))
      (when-in-hash (static "Static" character)
        (format #t "| **Static:** ~A~%" static))
      (when-in-hash (static "Defenses" character)
        (format #t "| **Defenses:** ~A~%" static))
      (when-in-hash (move "Move" character)
        (format #t "| **Move:** ~A~%" move))
      (when-in-hash (melee "Melee" character)
        (when (> (vector-length melee) 0)
          (format #t "| **Melee:** ")
          (loop for weapon across melee
                for i from 1
                when (> i 1) do (format #t "; ")
                do (format #t "~A" weapon))
          (format #t "~%")))
      (when-in-hash (ranged "Ranged" character)
        (when (> (vector-length ranged) 0)
          (format #t "| **Ranged:** ")
          (loop for weapon across ranged
                for i from 1
                when (> i 1) do (format #t "; ")
                do (format #t "~A" weapon))
          (format #t "~%")))
      (when-in-hash (natural-armor "Natural Armor" character)
        (when (> (vector-length natural-armor) 0)
          (format #t "| **Natural Armor:** ")
          (loop for armor across natural-armor
                for i from 1
                when (> i 1) do (format #t "; ")
                do (format #t "~A" armor))
          (format #t "~%")))
      (when-in-hash (natural-weapons "Natural Weapons" character)
        (when (> (vector-length natural-weapons) 0)
          (format #t "| **Natural Weapons:** ")
          (loop for weapon across natural-weapons
                for i from 1
                when (> i 1) do (format #t "; ")
                do (format #t "~A" weapon))
          (format #t "~%")))
      (when-in-hash (special-defenses "Special Defenses" character)
        (when (> (vector-length special-defenses) 0)
          (format #t "| **Special Defenses:** ")
          (loop for defense across special-defenses
                for i from 1
                when (> i 1) do (format #t "; ")
                do (format #t "~A" defense))
          (format #t "~%")))
      (when-in-hash (perks "Perks" character)
        (when (> (vector-length perks) 0)
	  (format #t "| **Perks:** ")
	  (loop for perk across perks
                for i from 1
                when (> i 1) do (format #t ", ")
	        do (match-let ((#(perk-name perk-dice) perk))
                     (format #t "~A ~A" perk-name perk-dice)))
          (format #t "~%")))
      (when-in-hash (complications "Complications" character)
        (when (> (vector-length complications) 0)
          (format #t "| **Complications:** ")
          (loop for complication across complications
                for i from 1
                when (> i 1) do (format #t ", ")
                do (format #t "~A" complication))
          (format #t "~%")))
      (when-in-hash (special-abilities "Special Abilities" character)
        (when (> (vector-length special-abilities) 0)
          (format #t "| **Special Abilities:** ")
          (loop for ability across special-abilities
                for i from 1
                when (> i 1) do (format #t "; ")
                do (format #t "~A" ability))
          (format #t "~%")))
      (when-in-hash (powers "Powers" character)
        (when (> (vector-length powers) 0)
          (format #t "| **Powers:** ")
          (loop for power across powers
                for i from 1
                when (> i 1) do (format #t ", ")
                do (format #t "~A" power))
          (format #t "~%")))
      (when-in-hash (spells "Spells" character)
        (when (> (vector-length spells) 0)
          (format #t "| **Spells:** ")
          (loop for spell across spells
                for i from 1
                when (> i 1) do (format #t ", ")
                do (format #t "~A" spell))
          (format #t "~%")))      
      (when-in-hash (gear "Gear" character)
        (when (> (vector-length gear) 0)
          (format #t "| **Gear:** ")
          (loop for g across gear
                for i from 1
                when (> i 1) do (format #t ", ")
                do (format #t "~A" g))
          (format #t "~%")))
      (when-in-hash (hero-points "Hero_Points" character)
        (format #t "| **Hero Points:** ~A~%" hero-points))
      (when-in-hash (fate-points "Fate_Points" character)
        (format #t "| **Fate Points:** ~A~%" fate-points))
      (when-in-hash (force-points "Force_Points" character)
        (format #t "| **Force Points:** ~A~%" force-points))
      (cond (output-breachworld
             (format #t "| **WL:** D:1–3 □ W:4–8 □ SW:4–8 □ I:9–12 □ MW:13–15 □~%")
             (format #t "| **SL:** S:1–8 □ SS:9+ □~%"))
            (else 
             (format #t "| **WL:** S:1–3 □ W:4–8 □ SW:4–8 □ I:9–12 □ MW:13–15 □~%")))
      (when-in-hash (image "Image" character)
        (format #t "~%.. image:: ~A~%" image)
        (when outer-name 
          (format #t   "   :alt: ~A~%" outer-name)))
      (when-in-hash (notes "Notes" character)
        (when (> (vector-length notes) 0)
          (format #t "~%")
          (loop for line across notes
                do (output-notes-line line))
          (format #t "~%")))))

  (define (process-filename filename)
    (let ((characters (with-input-from-file filename read-json)))
      (loop for character across characters
	    for i from 1
	    when (> i 1) do (format #t "~%~%")
	    do (print-character character))))

  ;; We want 
  (json-parsers
   `(;; Don't change key to symbol
     (member . ,(lambda (name value) (cons name value)))
     ;; Convert objects from alist to hash table
     (object . ,(lambda (object) (alist->hash-table object)))
     ,@(json-parsers)))

  (define output-generated #f)
  (define output-player #t)
  (define output-title #f)
  (define output-breachworld #f)
  ;;(define chunk #f)
  (define debug #f)
  (define underline #\-)
  (define substitute-from #f)
  (define substitute-to #f)

  (define opts
    (list (args:make-option
           (b breachworld) #:none "Output different wound track for Breachworld."
           (set! output-breachworld (not output-breachworld)))
          ;;(args:make-option (c chunk) #:none "Chunk output into separate files."
          ;; (set! chunk #t))
          (args:make-option
           (d debug) #:none "Output character for debugging"
           (set! debug (not debug)))
          (args:make-option
           (g generated) #:none "Output a generated date only if title specified."
           (set! output-generated (not output-generated)))
	  (args:make-option
           (h help) #:none "Display this text"
           (usage))
          (args:make-option
           (p player) #:none "Toggle player name output (default ON)"
           (set! output-player (not output-player)))
          (args:make-option
           (s substitute) #:required 
           (string-append
            "Substitute a whole line of the first character of ARG\n"
            "                          with the second character of ARG throughout\n"
            "                          the \"Notes:\" field.")
           (assert (= (string-length arg) 2))
           ;; Ok, I should generalize this so it pushes a new regex and
           ;; character on a list and then runs down the list trying each
           ;; regex and if it matches use the appropriate character.
           (set! substitute-from (irregex (string-append
                                           "^" (substring arg 0 1) "+" "$")))
           (set! substitute-to (string-ref arg 1)))
          (args:make-option
           (t title) #:required "Set title to output."
           (set! output-title arg))
          (args:make-option
           (u underline) #:required "Set character to use for underlining the header."
           (set! underline (string-ref arg 0)))))

  (define (usage)
    (with-output-to-port (current-error-port)
      (lambda ()
	(print "Usage: " (program-name) " [options...] [files...]")
	(newline)
	(print (args:usage opts))
	(format #t "Current argv: ~s~%" (argv))))
    (exit 1))

  (receive (options operands)
      (args:parse (command-line-arguments) opts)
    (when #f
      (format #t "output-player: ~A~%output-title: ~A~%" output-player
              output-title)
      (format #t "options: ~S~%operands: ~S~%" options operands))

    (when (= (length operands) 0)
      (die 1 "No filenames specified!"))
    (when output-title
      (format #t "~A~%~A~%~%~%" output-title
              (make-string (string-length output-title) #\@))
      (when output-generated
        (format #t "*Generated: ~A*~%~%~%"
                (date->string (current-date) "~Y-~m-~d ~T (~A, ~e ~B ~Y)"))))

    (loop for filename in operands
          for i from 1
          when (> i 1) do (format #t "~%~%~%")
          do (process-filename filename)))
  )
;; end of sm6rst.scm
